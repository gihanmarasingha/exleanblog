import data.nat.basic tactic data.nat.parity

namespace exlean

namespace wf_exlean

section logarithms

/-!
## Logarithms

We define a function `lg` that is (roughly) the base-2 logarithm. More precisely,

  `(n + 1) < 2 ^ lg (n + 1) ≤ 2 * (n + 1)`

for every `n : ℕ`. We prove the first of these inequalities.
-/

/--
`myF x h` gives the value of `lg x` where `h y` is `lg y` for `y < x`.
-/
def myF : Π (x : ℕ) (h : Π (y : ℕ), y < x → ℕ), ℕ
| 0 := 0
| (x + 1) := λ h, 1 + h ((x + 1) / 2) (nat.div_lt_self' x 0)

/-!
We prove that `myF` leads to well-founded recursive definition, which we call `lg_by_hand`.
-/

/--
`lg_by_hand x = floor (log₂ x) + 1`
-/
def lg_by_hand := well_founded.fix nat.lt_wf myF

/-!
`lg` is (extensionally) equal to `lg_by_hand`. Rather than using `well_founded.fix` and an
auxiliary function (such as `myF` above), we use the equation compiler to define the function
in one step.
-/

/--
`lg x = floor (log₂ x) + 1`
-/
def lg : ℕ → ℕ
| 0 := 0
| (x + 1) := have (x + 1) / 2 < (x + 1), from nat.div_lt_self' x 0,
    1 + lg ((x + 1)/2)

lemma lg_one : lg 1 = 1 := by { rw lg, norm_num, rw lg, }

/-!
### Proving log inequalities

We now show  `(n + 1) < 2 ^ lg (n + 1) ≤ 2 * (n + 1)` for each `n : ℕ`. The proof involves
well-founded recursion.
-/

lemma two_mul_succ_div_two {m : ℕ} : (2 * m + 1) / 2 = m :=
begin
  rw [nat.succ_div, if_neg], norm_num,
  rintros ⟨k, h⟩, exact nat.two_mul_ne_two_mul_add_one h.symm,
end

def lg_ineq : ℕ → Prop := λ n, n + 1 < 2 ^ lg (n + 1)

/--
`lg_lemma_aux` is an auxiliary lemma used to show `lg x` satisfies the desired lower bound on
the assumpion that `lg y` also satisfies the correct bound, for every `y < x`.
-/

lemma lg_lemma_aux (x : ℕ) (h : Π (y : ℕ), y < x → lg_ineq y) : lg_ineq x :=
begin
  cases x,
  { rw [lg_ineq, lg_one], norm_num, }, -- base case
  dsimp [lg_ineq] at h ⊢,
  rcases nat.even_or_odd x with ⟨m, rfl⟩ | ⟨m, rfl⟩,
  { have h₄ : m < 2 * m + 1, by linarith,
    specialize h m h₄, rw [nat.succ_eq_add_one, lg, pow_add],
    rw (show 2 * m + 1 + 1 = 2 * (m + 1), by linarith), norm_num, exact h, },
  { have h₄ : m < 2 * m + 1 + 1, by linarith,
    specialize h m h₄, rw [lg, pow_add],
    rw (show 2 * m + 1 + 1 + 1 = 2 * (m + 1) + 1, by linarith),
    rw two_mul_succ_div_two, linarith, }, 
end

/--
`lg_lemma` is the lower bound result for `lg x`. It uses well-founded recursion and `lg_lemma_aux`.
-/
lemma lg_lemma : ∀ (x : ℕ), x + 1 < 2 ^ lg (x + 1) := well_founded.fix nat.lt_wf lg_lemma_aux

/--
`lg_lemma2` is the lower bound result for `lg x`. In contrast to `lg_lemma`, this proof uses the
equation compiler to bypass the application of `well_founded.fix`.

At two points in the proof, we supply inequalities needed to show that the recursive application
is decreasing. These must be provided in term mode.
-/
lemma lg_lemma2 : ∀ (x : ℕ), x + 1 < 2 ^ lg (x + 1)
| 0 := by { rw lg_one, norm_num, }
| (x + 1) := or.elim (nat.even_or_odd x)
( λ ⟨m, hm⟩,
  have m < x + 1, by linarith, -- needed for wf recursion
  begin
    specialize lg_lemma2 m, rw [hm, lg, pow_add],
    rw (show 2 * m + 1 + 1 = 2 * (m + 1), by linarith), norm_num, exact lg_lemma2,
  end )
( λ ⟨m, hm⟩,
  have m < x + 1, by linarith, -- needed for wf recursion
  begin
    specialize lg_lemma2 m, rw [hm, lg, pow_add],
    rw (show 2 * m + 1 + 1 + 1 = 2 * (m + 1) + 1, by linarith), rw two_mul_succ_div_two, linarith,
  end )

end logarithms

section prime_factors

/-
The following is adapted from `data.nat.prime` in mathlib. Here the normal `<` relation isn't what
we want because we're computing `min_fac_aux k` using a value for `min_fac_aux (k + 2)`.

But clearly `k + 2 < k` is false! Instead, we use a relation generated by a 'measure', that is,
a function `f : α → ℕ`. In our case, we take `f` so that `f k = sqrt n + 2 - k`, where `n` is fixed.

Let `≺` denote the relation on `ℕ` generated by `f`. By definition, `a ≺ b` means `f a < f b`.
It's a theorem that for every measure `f`, the relation `≺` is well-founded.

We ask Lean to use this relation via the command

``using_well_founded {rel_tac := λ _ _, `[exact ⟨_, measure_wf (λ k, sqrt n + 2 - k)⟩]}``

What remains is to show that the recursive application in decreasing. Recall we want to define
`min_fac_aux k` in terms of `min_fac_aux (k + 2)`. We must show `f (k + 2) < f k`.

This is precisely the assertion of `min_fac_lemma`.
-/

open nat

def min_fac_aux (n : ℕ) : ℕ → ℕ | k :=
if h : n < k * k then n else
if k ∣ n then k else
have sqrt n - k < sqrt n + 2 - k, -- needed for wf recursion
{ rw nat.sub_lt_sub_right_iff, norm_num, rw nat.le_sqrt, exact le_of_not_gt h, },
min_fac_aux (k + 2)
using_well_founded {rel_tac := λ _ _, `[exact ⟨_, measure_wf (λ k, sqrt n + 2 - k)⟩]}

end prime_factors

end wf_exlean

end exlean